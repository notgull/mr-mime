//! Generates the `segments.rs` file for interned strings.

use fastrand::Rng;
use heck::{AsShoutySnakeCase, AsSnakeCase, AsUpperCamelCase, ToUpperCamelCase};
use intern_str::builder::{Builder, IgnoreCase, Utf8Graph};
use memchr::memchr;

use std::collections::HashSet;
use std::env;
use std::fmt;
use std::fs::File;
use std::io::{self, prelude::*, BufReader, BufWriter};

fn main() -> io::Result<()> {
    // Ensure that the process is deterministic using a set key.
    let rng = Rng::with_seed(0xD3ADB33F);

    // Determine the files to read from/write to.
    let mut args = env::args_os().skip(1);
    let input = args.next().unwrap_or_else(|| "mime.types".into());
    let output = args.next().unwrap_or_else(|| "segments.rs".into());

    // Open the input file.
    let input = File::open(input)?;
    let input = BufReader::new(input);

    // Read MIME types from the file.
    let mime_types = input
        .lines()
        .filter_map(|line| {
            line.map(|line| {
                let line = line.trim();
                if line.is_empty() || line.starts_with('#') {
                    None
                } else {
                    let ty = line.split_whitespace().next().unwrap().to_string();
                    Mime::parse(ty)
                }
            })
            .transpose()
        })
        .collect::<io::Result<Vec<_>>>()?;

    // Open the output file.
    let output = File::create(output)?;
    let mut output = BufWriter::new(output);

    // Begin writing to the output.
    writeln!(
        output,
        "// This file is automatically generated by `mr-mime-generator`. Do not edit.\n"
    )?;

    // Write enums for the MIME types.
    write_mime_part(
        &mut output,
        "Type",
        &mime_types,
        |ty| Some(&ty.ty),
        true,
        &rng,
    )?;
    write_mime_part(
        &mut output,
        "Subtype",
        &mime_types,
        |ty| Some(&ty.subtype),
        true,
        &rng,
    )?;
    write_mime_part(
        &mut output,
        "Suffix",
        &mime_types,
        |ty| ty.suffix.as_deref(),
        false,
        &rng,
    )?;

    // Write `MIME` type constants.
    writeln!(output)?;
    writeln!(output, "/// Constants for common MIME types and subtypes.")?;
    writeln!(output, "pub mod constants {{")?;
    let mut existing_names = HashSet::new();

    for mime in mime_types {
        if mime
            .subtype
            .chars()
            .next()
            .filter(|c| c.is_ascii_alphabetic())
            .is_none()
        {
            continue;
        }

        match mime
            .suffix
            .as_ref()
            .map(|s| s.to_upper_camel_case().to_lowercase())
            .as_deref()
        {
            Some("hdr") | Some("src") => continue,
            _ => {}
        }

        let name = format!(
            "{}_{}{}",
            AsShoutySnakeCase(&mime.ty),
            AsShoutySnakeCase(&mime.subtype),
            match mime.suffix {
                Some(ref suffix) => format!("_{}", AsShoutySnakeCase(suffix)),
                None => String::new(),
            },
        );

        if !existing_names.insert(name.clone()) {
            continue;
        }

        writeln!(output, "{}/// `{}`", Indent(1), mime,)?;
        writeln!(
            output,
            "{}pub const {}: crate::Mime<'static> = crate::Mime(crate::Repr::Parts {{",
            Indent(1),
            name,
        )?;
        writeln!(
            output,
            "{}ty: crate::Name::Interned(super::Type::{}),",
            Indent(2),
            AsUpperCamelCase(&mime.ty),
        )?;
        writeln!(
            output,
            "{}subtype: crate::Name::Interned(super::Subtype::{}),",
            Indent(2),
            AsUpperCamelCase(&mime.subtype),
        )?;
        writeln!(
            output,
            "{}suffix: {},",
            Indent(2),
            match mime.suffix {
                Some(ref suffix) => format!(
                    "Some(crate::Name::Interned(super::Suffix::{}))",
                    AsUpperCamelCase(suffix)
                ),
                None => "None".to_string(),
            },
        )?;
        writeln!(output, "{}parameters: &[]", Indent(2))?;
        writeln!(output, "{}}});", Indent(1))?;
        writeln!(output)?;

        writeln!(output, "{}#[test]", Indent(1))?;
        writeln!(output, "{}fn {}_parse() {{", Indent(1), AsSnakeCase(&name))?;

        // Parse the MIME type as a string.
        let mime_txt = mime.to_string();
        writeln!(
            output,
            "{}assert_eq!(crate::Mime::parse(\"{}\"), Ok({}));",
            Indent(2),
            &mime_txt,
            name,
        )?;

        let mime_text = random_case_str(&mime_txt, &rng);
        writeln!(
            output,
            "{}assert_eq!(crate::Mime::parse(\"{}\"), Ok({}));",
            Indent(2),
            mime_text,
            name,
        )?;

        writeln!(output, "{}}}", Indent(1))?;
        writeln!(output)?;
    }

    writeln!(output, "}}")?;

    Ok(())
}

fn write_mime_part(
    output: &mut impl Write,
    name: &str,
    types: &[Mime],
    get_field: impl Fn(&Mime) -> Option<&str>,
    has_star: bool,
    rng: &Rng,
) -> io::Result<()> {
    // Get an iterator over every possible value.
    let mut types = types
        .iter()
        .filter_map(get_field)
        .filter(|name| {
            name.chars()
                .next()
                .filter(|c| c.is_ascii_alphabetic())
                .is_some()
        })
        .map(|name| (name, name.to_upper_camel_case()))
        .collect::<Vec<_>>();
    types.sort_unstable_by(|a, b| a.1.cmp(&b.1));
    types.dedup_by(|a, b| a.1 == b.1);

    // Write out the enum.
    writeln!(
        output,
        "#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]"
    )?;
    writeln!(output, "pub(crate) enum {} {{", name)?;

    // Write asterisk.
    if has_star {
        writeln!(output, "{}Star,", Indent(1))?;
    }

    // Write out each member.
    for (_, field) in &types {
        writeln!(output, "{}{},", Indent(1), field)?;
    }

    writeln!(output, "}}")?;

    // Begin implementation work.
    writeln!(output)?;
    writeln!(output, "impl {} {{", name)?;

    // Write out an "as_str" method.
    writeln!(
        output,
        "{}pub(crate) fn as_str(self) -> &'static str {{",
        Indent(1)
    )?;
    writeln!(output, "{}match self {{", Indent(2))?;

    if has_star {
        writeln!(output, "{}{}::Star => \"*\",", Indent(3), name)?;
    }

    for (realtext, field) in &types {
        writeln!(
            output,
            "{}{}::{} => \"{}\",",
            Indent(3),
            name,
            field,
            realtext
        )?;
    }

    writeln!(output, "{}}}", Indent(2))?;
    writeln!(output, "{}}}", Indent(1))?;
    writeln!(output, "}}")?;

    // Write out a "from_str" method.
    writeln!(output, "impl core::str::FromStr for {} {{", name)?;
    writeln!(output, "{}type Err = crate::InvalidName;", Indent(1))?;
    writeln!(output)?;
    writeln!(
        output,
        "{}fn from_str(s: &str) -> Result<Self, Self::Err> {{",
        Indent(1)
    )?;

    // Begin creating the graph.
    let mut builder = Builder::<_, IgnoreCase<Utf8Graph>>::new();

    if has_star {
        builder.add("*".to_string(), "Star").ok();
    }

    for (realtext, field) in &types {
        builder.add(realtext.to_string(), field).ok();
    }

    let mut buffer = vec![];
    let graph = builder.build(&mut buffer);

    // Write out the graph.
    let outname = format!("Option<{}>", name);
    let generated = intern_str_codegen::generate(
        &graph,
        "intern_str::CaseInsensitive<&'static str>",
        &outname,
        |f, n| match n.as_ref() {
            None => write!(f, "None"),
            Some(n) => write!(f, "Some({}::{})", name, n),
        },
    );
    writeln!(
        output,
        "{}const GRAPH: intern_str::Graph<'static, 'static, intern_str::CaseInsensitive<&'static str>, {}> = {};",
        Indent(2),
        &outname,
        generated
    )?;

    // Write out the lookup.
    writeln!(
        output,
        "{}GRAPH.process(intern_str::CaseInsensitive(s)).as_ref().copied().ok_or(crate::InvalidName)",
        Indent(2)
    )?;
    writeln!(output, "{}}}", Indent(1))?;

    writeln!(output, "}}")?;
    writeln!(output)?;

    // Add a test for the string parser.
    writeln!(output, "#[test]")?;
    writeln!(output, "fn {}_from_str() {{", AsSnakeCase(name))?;

    if has_star {
        writeln!(
            output,
            "{}assert_eq!(\"*\".parse::<{}>(), Ok({}::Star));",
            Indent(1),
            name,
            name
        )?;
    }

    for (realtext, field) in &types {
        writeln!(
            output,
            "{}assert_eq!(\"{}\".parse::<{}>(), Ok({}::{}));",
            Indent(1),
            realtext,
            name,
            name,
            field,
        )?;

        // We should also parse with random spacing.
        let field_next = random_case_str(realtext, rng);

        writeln!(
            output,
            "{}assert_eq!(\"{}\".parse::<{}>(), Ok({}::{}));",
            Indent(1),
            field_next,
            name,
            name,
            field,
        )?;
    }

    writeln!(output, "}}")?;
    writeln!(output)?;

    // Add an AsRef<str> impl.
    writeln!(output, "impl AsRef<str> for {} {{", name)?;
    writeln!(
        output,
        "{}fn as_ref(&self) -> &str {{ self.as_str() }}",
        Indent(1)
    )?;
    writeln!(output, "}}")?;
    writeln!(output)?;

    // Add an Into<&'static str> impl
    writeln!(output, "impl From<{}> for &'static str {{", name)?;
    writeln!(
        output,
        "{}fn from(name: {}) -> Self {{ name.as_str() }}",
        Indent(1),
        name
    )?;
    writeln!(output, "}}")?;
    writeln!(output)?;

    Ok(())
}

struct Mime {
    /// The MIME type.
    ty: String,

    /// The MIME subtype.
    subtype: String,

    /// The MIME suffix.
    suffix: Option<String>,
}

impl Mime {
    /// Parses a MIME type from a string.
    fn parse(mut s: String) -> Option<Self> {
        // Split the MIME type off.
        let slash = memchr(b'/', s.as_bytes())?;
        let rest = s.split_off(slash + 1);
        let mut ty = s;
        ty.pop();
        s = rest;

        // Now all we have to do it split the subtype and suffix by +
        let (subtype, suffix) = if let Some(plus) = memchr(b'+', s.as_bytes()) {
            if plus == s.len() - 1 {
                (s, None)
            } else {
                let rest = s.split_off(plus + 1);
                let mut subtype = s;
                subtype.pop();
                (subtype, Some(rest))
            }
        } else {
            (s, None)
        };

        Some(Self {
            ty,
            subtype,
            suffix,
        })
    }
}

impl fmt::Display for Mime {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}/{}", self.ty, self.subtype)?;

        if let Some(suffix) = &self.suffix {
            write!(f, "+{}", suffix)?;
        }
        Ok(())
    }
}

struct Indent(usize);

impl fmt::Display for Indent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        for _ in 0..self.0 {
            write!(f, "    ")?;
        }
        Ok(())
    }
}

/// Randomize the case of a string.
fn random_case_str(a: &str, rng: &Rng) -> String {
    a.chars()
        .map(|c| {
            if rng.bool() {
                c.to_ascii_lowercase()
            } else {
                c.to_ascii_uppercase()
            }
        })
        .collect()
}
